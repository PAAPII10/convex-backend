name: Deploy Convex Self-Hosted Backend

on:
  push:
    branches: [ 'main' ]
    paths:
      - 'convex-backend/**'
      - '.github/workflows/deploy.yml'

env:
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  PRIVATE_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
  USERNAME: ${{ secrets.EC2_USERNAME }}
  HOST_DNS: ${{ secrets.HOST_DNS }}
  AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  CONVEX_ENV: ${{ secrets.CONVEX_ENV }}

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout Source
      uses: actions/checkout@v4

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_DEFAULT_REGION }}

    - name: Encode CONVEX_ENV for safe transmission
      id: encode_env
      run: |
        ENCODED=$(echo -n "${{ env.CONVEX_ENV }}" | base64 | tr -d '\n')
        echo "CONVEX_ENV_B64=$ENCODED" >> $GITHUB_OUTPUT

    - name: SSH into EC2 instance and deploy
      uses: appleboy/ssh-action@master
      with:
        host: ${{ env.HOST_DNS }}
        username: ${{ env.USERNAME }}
        key: ${{ env.PRIVATE_SSH_KEY }}
        script: |
          set -e
          
          echo "üöÄ Starting Convex Backend Deployment..."
          
          # Navigate to convex-backend directory (create if doesn't exist)
          mkdir -p ~/convex-backend
          cd ~/convex-backend
          
          # Check if docker-compose.prod.yml exists, if not download official version
          if [ ! -f docker-compose.prod.yml ]; then
            echo "üì¶ Docker Compose file not found. Setting up files..."
            if [ -d ".git" ]; then
              echo "‚úÖ Git repository found, files should be present"
            else
              echo "üì• Downloading official docker-compose.yml and adapting for production..."
              curl -s https://raw.githubusercontent.com/get-convex/convex-backend/main/self-hosted/docker/docker-compose.yml -o docker-compose.prod.yml
              # Modify for production: bind to localhost only
              sed -i 's/- "${PORT:-3210}:3210"/- "127.0.0.1:3210:3210"/' docker-compose.prod.yml
              sed -i 's/- "${SITE_PROXY_PORT:-3211}:3211"/- "127.0.0.1:3211:3211"/' docker-compose.prod.yml
              sed -i 's/- "${DASHBOARD_PORT:-6791}:6791"/- "127.0.0.1:6791:6791"/' docker-compose.prod.yml
              echo "‚úÖ Created docker-compose.prod.yml from official source"
            fi
          fi
          
          # Create or update .env file from GitHub secret
          echo "üìù Configuring environment variables..."
          # Decode base64 encoded environment variables and write to .env file
          echo "${{ steps.encode_env.outputs.CONVEX_ENV_B64 }}" | base64 -d > .env
          
          # Remove comment lines from .env file (lines starting with #)
          echo "üßπ Cleaning .env file (removing comments and empty lines)..."
          sed -i '/^[[:space:]]*#/d' .env
          sed -i '/^[[:space:]]*$/d' .env
          
          echo "‚úÖ .env file created and cleaned"
          
          echo "‚úÖ Checking POSTGRES_URL is set..."
          if grep -q "POSTGRES_URL" .env; then
            echo "‚úÖ POSTGRES_URL found in .env"
          else
            echo "‚ö†Ô∏è  WARNING: POSTGRES_URL not found in .env (will use SQLite if not set)"
          fi
          
          # Ensure Docker is running
          sudo systemctl start docker || true
          sudo chmod 666 /var/run/docker.sock || true
          
          # Detect docker-compose command
          echo "üîç Detecting Docker Compose command..."
          DOCKER_COMPOSE_CMD=""
          if command -v docker-compose &> /dev/null; then
            DOCKER_COMPOSE_CMD="docker-compose"
            echo "‚úÖ Using docker-compose (standalone)"
          elif docker compose version &> /dev/null; then
            DOCKER_COMPOSE_CMD="docker compose"
            echo "‚úÖ Using docker compose (plugin)"
          else
            echo "‚ùå Docker Compose not found. Installing..."
            sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
            DOCKER_COMPOSE_CMD="docker-compose"
            echo "‚úÖ Installed docker-compose"
          fi
          
          echo "üì• Pulling latest Docker images..."
          $DOCKER_COMPOSE_CMD -f docker-compose.prod.yml pull
          
          echo "üîÑ Stopping existing services..."
          $DOCKER_COMPOSE_CMD -f docker-compose.prod.yml down || true
          
          echo "‚úÖ Starting services with latest images..."
          $DOCKER_COMPOSE_CMD -f docker-compose.prod.yml up -d || true
          
          echo "‚è≥ Waiting a moment for containers to start..."
          sleep 3
          
          echo "üìã Checking container status..."
          docker ps -a --filter "name=convex" || true
          
          echo "üìù Backend logs (last 100 lines):"
          $DOCKER_COMPOSE_CMD -f docker-compose.prod.yml logs backend --tail 100 2>&1 || docker logs convex-backend-backend-1 --tail 100 2>&1 || echo "Could not retrieve logs"
          
          echo "üìù Checking if backend container exists and its exit code:"
          docker inspect convex-backend-backend-1 --format '{{.State.Status}} - Exit Code: {{.State.ExitCode}}' 2>&1 || echo "Container not found"
          
          # Test connectivity from inside the container if it exists
          if docker ps -a --format '{{.Names}}' | grep -q "convex-backend-backend-1"; then
            echo "üåê Testing network connectivity from inside backend container..."
            POSTGRES_HOST=$(grep POSTGRES_URL .env | sed 's/.*@\([^:]*\):.*/\1/' || echo "")
            if [ -n "$POSTGRES_HOST" ]; then
              echo "Testing from container to: $POSTGRES_HOST:6543"
              docker exec convex-backend-backend-1 sh -c "timeout 5 bash -c 'cat < /dev/null > /dev/tcp/$POSTGRES_HOST/6543'" 2>&1 && echo "‚úÖ Container can reach Supabase" || echo "‚ùå Container CANNOT reach Supabase"
              # Try with nc if available in container
              docker exec convex-backend-backend-1 sh -c "timeout 5 nc -zv $POSTGRES_HOST 6543" 2>&1 || echo "Container nc test failed or nc not available"
            fi
          fi
          
          echo "üìù Checking .env file (first few lines, masked):"
          head -5 .env | sed 's/=.*/=***/' || true
          
          # Test connectivity from host before starting containers
          echo "üåê Pre-flight network connectivity test..."
          POSTGRES_HOST=$(grep POSTGRES_URL .env | sed 's/.*@\([^:]*\):.*/\1/' || echo "")
          if [ -n "$POSTGRES_HOST" ]; then
            echo "Testing from host to: $POSTGRES_HOST:6543"
            if timeout 10 bash -c "cat < /dev/null > /dev/tcp/$POSTGRES_HOST/6543" 2>/dev/null; then
              echo "‚úÖ Host can reach Supabase on port 6543"
            else
              echo "‚ùå Host CANNOT reach Supabase on port 6543"
              echo "‚ö†Ô∏è  This indicates an EC2 Security Group issue!"
              echo "   Fix: AWS Console ‚Üí EC2 ‚Üí Security Groups ‚Üí Add Outbound Rule:"
              echo "   - Type: Custom TCP"
              echo "   - Port: 6543"
              echo "   - Destination: 0.0.0.0/0"
            fi
          fi
          
          echo "üåê Testing network connectivity to Supabase from containers..."
          POSTGRES_HOST=$(grep POSTGRES_URL .env | sed 's/.*@\([^:]*\):.*/\1/' || echo "")
          if [ -n "$POSTGRES_HOST" ]; then
            echo "Testing connection to: $POSTGRES_HOST:6543"
            
            # Get IPv4 address
            POSTGRES_IP=$(getent hosts $POSTGRES_HOST | awk '{print $1}' | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$' | head -1)
            if [ -n "$POSTGRES_IP" ]; then
              echo "Resolved to IPv4: $POSTGRES_IP"
              echo "Testing IPv4 connection..."
              timeout 5 bash -c "echo > /dev/tcp/$POSTGRES_IP/6543" 2>&1 && echo "‚úÖ IPv4 Port 6543 is reachable" || echo "‚ùå IPv4 Port 6543 is NOT reachable"
              timeout 5 nc -zv -4 $POSTGRES_IP 6543 2>&1 || echo "IPv4 nc test failed"
            else
              echo "‚ö†Ô∏è  Could not resolve IPv4 address"
            fi
            
            # Test with hostname (may use IPv6)
            echo "Testing with hostname (may use IPv6)..."
            timeout 5 bash -c "echo > /dev/tcp/$POSTGRES_HOST/6543" 2>&1 && echo "‚úÖ Port 6543 is reachable" || echo "‚ùå Port 6543 is NOT reachable"
            timeout 5 nc -zv $POSTGRES_HOST 6543 2>&1 || echo "nc test failed"
            
            # Test with telnet if available
            if command -v telnet &> /dev/null; then
              echo "Testing with telnet..."
              echo "quit" | timeout 5 telnet $POSTGRES_HOST 6543 2>&1 | head -3 || echo "Telnet test failed"
            fi
          fi
          
          echo "üîç Checking EC2 security group configuration..."
          echo "Current outbound rules (if available):"
          # Try to get security group info (may not work without AWS CLI configured)
          echo "Note: Check AWS Console ‚Üí EC2 ‚Üí Security Groups ‚Üí Outbound rules"
          echo "Required: Allow outbound TCP on port 6543 to 0.0.0.0/0"
          
          echo "‚è≥ Waiting for backend to be healthy..."
          sleep 10
          
          echo "üè• Checking backend health..."
          if curl -f http://localhost:3210/version > /dev/null 2>&1; then
            echo "‚úÖ Backend is healthy!"
          else
            echo "‚ö†Ô∏è  Backend health check failed!"
            echo "üìù Full backend logs:"
            $DOCKER_COMPOSE_CMD -f docker-compose.prod.yml logs backend 2>&1 || docker logs convex-backend-backend-1 2>&1 || true
            echo "üìù Checking POSTGRES_URL:"
            grep "POSTGRES_URL" .env | head -1 | sed 's/=.*/=***/' || echo "POSTGRES_URL not found in .env"
            echo "üåê Network diagnostics:"
            echo "Testing internet connectivity:"
            curl -s --max-time 5 https://www.google.com > /dev/null && echo "‚úÖ Internet connection works" || echo "‚ùå No internet connection"
            echo "Testing DNS resolution:"
            POSTGRES_HOST=$(grep POSTGRES_URL .env | sed 's/.*@\([^:]*\):.*/\1/' || echo "")
            if [ -n "$POSTGRES_HOST" ]; then
              echo "DNS lookup for $POSTGRES_HOST:"
              nslookup $POSTGRES_HOST 2>&1 | head -10 || echo "DNS lookup failed"
              echo ""
              echo "IPv4 addresses:"
              getent hosts $POSTGRES_HOST | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+' || echo "No IPv4 addresses found"
              echo ""
              echo "IPv6 addresses:"
              getent hosts $POSTGRES_HOST | grep -E '^[0-9a-fA-F:]+' || echo "No IPv6 addresses found"
            fi
            echo ""
            echo "üîß Troubleshooting steps:"
            echo "1. Check EC2 Security Group ‚Üí Outbound rules:"
            echo "   - Type: Custom TCP"
            echo "   - Port: 6543"
            echo "   - Destination: 0.0.0.0/0 (or specific Supabase IP)"
            echo ""
            echo "2. Verify Supabase database is accessible:"
            echo "   - Check Supabase Dashboard ‚Üí Settings ‚Üí Database"
            echo "   - Ensure connection pooler (port 6543) is enabled"
            echo ""
            echo "3. Test from EC2 instance directly:"
            echo "   ssh into EC2 and run: telnet db.rxzzrjokpozbmdzunkcr.supabase.co 6543"
            echo ""
            echo "4. Check Docker network configuration:"
            docker network inspect bridge 2>&1 | grep -A 5 "IPAM" || echo "Could not inspect Docker network"
            exit 1
          fi
          
          echo "üìä Service Status:"
          docker ps --filter "name=convex" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          
          echo ""
          echo "üìã Docker Compose Version:"
          $DOCKER_COMPOSE_CMD --version || $DOCKER_COMPOSE_CMD version
          
          echo ""
          echo "‚úÖ Deployment complete!"
