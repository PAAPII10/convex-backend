name: Deploy Convex Self-Hosted Backend

on:
  push:
    branches: [ 'main' ]
    paths:
      - 'convex-backend/**'
      - '.github/workflows/deploy.yml'

env:
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  PRIVATE_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
  USERNAME: ${{ secrets.EC2_USERNAME }}
  HOST_DNS: ${{ secrets.HOST_DNS }}
  AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  CONVEX_ENV: ${{ secrets.CONVEX_ENV }}

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout Source
      uses: actions/checkout@v4

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_DEFAULT_REGION }}

    - name: SSH into EC2 instance and deploy
      uses: appleboy/ssh-action@master
      with:
        host: ${{ env.HOST_DNS }}
        username: ${{ env.USERNAME }}
        key: ${{ env.PRIVATE_SSH_KEY }}
        script: |
          set -e
          
          echo "ðŸš€ Starting Convex Backend Deployment..."
          
          # Navigate to convex-backend directory (create if doesn't exist)
          mkdir -p ~/convex-backend
          cd ~/convex-backend
          
          # Check if docker-compose.prod.yml exists, if not download official version
          if [ ! -f docker-compose.prod.yml ]; then
            echo "ðŸ“¦ Docker Compose file not found. Setting up files..."
            if [ -d ".git" ]; then
              echo "âœ… Git repository found, files should be present"
            else
              echo "ðŸ“¥ Downloading official docker-compose.yml and adapting for production..."
              curl -s https://raw.githubusercontent.com/get-convex/convex-backend/main/self-hosted/docker/docker-compose.yml -o docker-compose.prod.yml
              # Modify for production: bind to localhost only
              sed -i 's/- "${PORT:-3210}:3210"/- "127.0.0.1:3210:3210"/' docker-compose.prod.yml
              sed -i 's/- "${SITE_PROXY_PORT:-3211}:3211"/- "127.0.0.1:3211:3211"/' docker-compose.prod.yml
              sed -i 's/- "${DASHBOARD_PORT:-6791}:6791"/- "127.0.0.1:6791:6791"/' docker-compose.prod.yml
              echo "âœ… Created docker-compose.prod.yml from official source"
            fi
          fi
          
          # Create or update .env file from GitHub secret
          echo "ðŸ“ Configuring environment variables..."
          printf '%s\n' "${{ env.CONVEX_ENV }}" > .env
          
          echo "âœ… .env file created (checking POSTGRES_URL is set)..."
          if grep -q "POSTGRES_URL" .env; then
            echo "âœ… POSTGRES_URL found in .env"
          else
            echo "âš ï¸  WARNING: POSTGRES_URL not found in .env (will use SQLite if not set)"
          fi
          
          # Configure IPv4 preference to avoid IPv6 connection issues
          # This ensures DNS resolution prefers IPv4 addresses
          echo "ðŸ”§ Configuring IPv4 preference for DNS resolution..."
          if [ -f /etc/gai.conf ]; then
            if ! grep -q "^precedence ::ffff:0:0/96  100" /etc/gai.conf; then
              echo "   Adding IPv4 preference to /etc/gai.conf..."
              sudo sh -c 'echo "precedence ::ffff:0:0/96  100" >> /etc/gai.conf' 2>&1 || echo "   âš ï¸  Could not modify /etc/gai.conf (may need sudo, continuing anyway)"
            else
              echo "   âœ… IPv4 preference already configured in /etc/gai.conf"
            fi
          else
            echo "   Creating /etc/gai.conf to prefer IPv4..."
            sudo sh -c 'echo "precedence ::ffff:0:0/96  100" > /etc/gai.conf' 2>&1 || echo "   âš ï¸  Could not create /etc/gai.conf (may need sudo, continuing anyway)"
          fi
          
          # Workaround: If POSTGRES_URL contains a hostname, try to resolve to IPv4 and use it
          # This helps when DNS returns IPv6 but EC2 doesn't have IPv6 connectivity
          if grep -q "POSTGRES_URL" .env; then
            POSTGRES_URL=$(grep "^POSTGRES_URL=" .env | cut -d'=' -f2-)
            if echo "$POSTGRES_URL" | grep -q "@.*:"; then
              HOSTNAME=$(echo "$POSTGRES_URL" | sed 's/.*@\([^:]*\):.*/\1/')
              PORT=$(echo "$POSTGRES_URL" | sed 's/.*:\([0-9]*\).*/\1/')
              echo "   Resolving $HOSTNAME to IPv4 address..."
              IPV4_ADDR=$(getent ahostsv4 "$HOSTNAME" 2>/dev/null | head -1 | awk '{print $1}' || echo "")
              if [ -n "$IPV4_ADDR" ] && [ "$IPV4_ADDR" != "$HOSTNAME" ]; then
                echo "   âœ… Found IPv4: $IPV4_ADDR"
                echo "   Updating POSTGRES_URL to use IPv4 address..."
                NEW_POSTGRES_URL=$(echo "$POSTGRES_URL" | sed "s/@${HOSTNAME}:/@${IPV4_ADDR}:/")
                sed -i "s|^POSTGRES_URL=.*|POSTGRES_URL=${NEW_POSTGRES_URL}|" .env
                echo "   âœ… Updated POSTGRES_URL to use IPv4"
              else
                echo "   âš ï¸  Could not resolve to IPv4, will use hostname (may fail if IPv6 is not available)"
              fi
            fi
          fi
          
          # Ensure Docker is running
          sudo systemctl start docker || true
          sudo chmod 666 /var/run/docker.sock || true
          
          # Detect docker-compose command
          echo "ðŸ” Detecting Docker Compose command..."
          DOCKER_COMPOSE_CMD=""
          if command -v docker-compose &> /dev/null; then
            DOCKER_COMPOSE_CMD="docker-compose"
            echo "âœ… Using docker-compose (standalone)"
          elif docker compose version &> /dev/null; then
            DOCKER_COMPOSE_CMD="docker compose"
            echo "âœ… Using docker compose (plugin)"
          else
            echo "âŒ Docker Compose not found. Installing..."
            sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
            DOCKER_COMPOSE_CMD="docker-compose"
            echo "âœ… Installed docker-compose"
          fi
          
          echo "ðŸ“¥ Pulling latest Docker images..."
          $DOCKER_COMPOSE_CMD -f docker-compose.prod.yml pull
          
          echo "ðŸ”„ Stopping existing services..."
          $DOCKER_COMPOSE_CMD -f docker-compose.prod.yml down || true
          
          echo "âœ… Starting services with latest images..."
          $DOCKER_COMPOSE_CMD -f docker-compose.prod.yml up -d || true
          
          echo "â³ Waiting a moment for containers to start..."
          sleep 3
          
          echo "ðŸ“‹ Checking container status..."
          docker ps -a --filter "name=convex" || true
          
          echo "ðŸ“ Backend logs (last 100 lines):"
          $DOCKER_COMPOSE_CMD -f docker-compose.prod.yml logs backend --tail 100 2>&1 || docker logs convex-backend-backend-1 --tail 100 2>&1 || echo "Could not retrieve logs"
          
          echo "ðŸ“ Checking if backend container exists and its exit code:"
          docker inspect convex-backend-backend-1 --format '{{.State.Status}} - Exit Code: {{.State.ExitCode}}' 2>&1 || echo "Container not found"
          
          echo "ðŸ“ Checking .env file (first few lines, masked):"
          head -5 .env | sed 's/=.*/=***/' || true
          
          echo "ðŸŒ Testing network connectivity to Supabase..."
          POSTGRES_HOST=$(grep POSTGRES_URL .env | sed 's/.*@\([^:]*\):.*/\1/' || echo "")
          if [ -n "$POSTGRES_HOST" ]; then
            echo "Testing connection to: $POSTGRES_HOST:6543"
            echo "IPv4 test:"
            timeout 5 nc -4 -zv $POSTGRES_HOST 6543 2>&1 && echo "âœ… IPv4 port 6543 is reachable" || echo "âŒ IPv4 port 6543 NOT reachable"
            echo "IPv6 test:"
            timeout 5 nc -6 -zv $POSTGRES_HOST 6543 2>&1 && echo "âœ… IPv6 port 6543 is reachable" || echo "âŒ IPv6 port 6543 NOT reachable (this is OK if EC2 doesn't have IPv6)"
            echo "Note: If IPv4 works but backend still fails, Docker may be using IPv6. Check Docker network settings."
          fi
          
          echo "â³ Waiting for backend to be healthy..."
          sleep 10
          
          echo "ðŸ¥ Checking backend health..."
          if curl -f http://localhost:3210/version > /dev/null 2>&1; then
            echo "âœ… Backend is healthy!"
          else
            echo "âš ï¸  Backend health check failed!"
            echo "ðŸ“ Full backend logs:"
            $DOCKER_COMPOSE_CMD -f docker-compose.prod.yml logs backend 2>&1 || docker logs convex-backend-backend-1 2>&1 || true
            echo "ðŸ“ Checking POSTGRES_URL:"
            grep "POSTGRES_URL" .env | head -1 | sed 's/=.*/=***/' || echo "POSTGRES_URL not found in .env"
            echo "ðŸŒ Network diagnostics:"
            echo "Testing internet connectivity:"
            curl -s --max-time 5 https://www.google.com > /dev/null && echo "âœ… Internet connection works" || echo "âŒ No internet connection"
            echo "Testing DNS resolution:"
            POSTGRES_HOST=$(grep POSTGRES_URL .env | sed 's/.*@\([^:]*\):.*/\1/' || echo "")
            if [ -n "$POSTGRES_HOST" ]; then
              nslookup $POSTGRES_HOST 2>&1 | head -5 || echo "DNS lookup failed"
            fi
            exit 1
          fi
          
          echo "ðŸ“Š Service Status:"
          docker ps --filter "name=convex" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          
          echo ""
          echo "ðŸ“‹ Docker Compose Version:"
          $DOCKER_COMPOSE_CMD --version || $DOCKER_COMPOSE_CMD version
          
          echo ""
          echo "âœ… Deployment complete!"
