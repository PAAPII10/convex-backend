name: Deploy Convex Self-Hosted Backend

on:
  push:
    branches: [ 'main' ]
    paths:
      - 'convex-backend/**'
      - '.github/workflows/deploy.yml'

env:
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  PRIVATE_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
  USERNAME: ${{ secrets.EC2_USERNAME }}
  HOST_DNS: ${{ secrets.HOST_DNS }}
  AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
  CONVEX_ENV: ${{ secrets.CONVEX_ENV }}

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout Source
      uses: actions/checkout@v4

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_DEFAULT_REGION }}

    - name: SSH into EC2 instance and deploy
      uses: appleboy/ssh-action@master
      with:
        host: ${{ env.HOST_DNS }}
        username: ${{ env.USERNAME }}
        key: ${{ env.PRIVATE_SSH_KEY }}
        script: |
          set -e
          
          echo "ðŸš€ Starting Convex Backend Deployment..."
          
          # Navigate to convex-backend directory (create if doesn't exist)
          mkdir -p ~/convex-backend
          cd ~/convex-backend
          
          # Check if docker-compose.prod.yml exists, if not download official version
          if [ ! -f docker-compose.prod.yml ]; then
            echo "ðŸ“¦ Docker Compose file not found. Setting up files..."
            if [ -d ".git" ]; then
              echo "âœ… Git repository found, files should be present"
            else
              echo "ðŸ“¥ Downloading official docker-compose.yml and adapting for production..."
              curl -s https://raw.githubusercontent.com/get-convex/convex-backend/main/self-hosted/docker/docker-compose.yml -o docker-compose.prod.yml
              # Modify for production: bind to localhost only
              sed -i 's/- "${PORT:-3210}:3210"/- "127.0.0.1:3210:3210"/' docker-compose.prod.yml
              sed -i 's/- "${SITE_PROXY_PORT:-3211}:3211"/- "127.0.0.1:3211:3211"/' docker-compose.prod.yml
              sed -i 's/- "${DASHBOARD_PORT:-6791}:6791"/- "127.0.0.1:6791:6791"/' docker-compose.prod.yml
              echo "âœ… Created docker-compose.prod.yml from official source"
            fi
          fi
          
          # Create or update .env file from GitHub secret
          echo "ðŸ“ Configuring environment variables..."
          printf '%s\n' "${{ env.CONVEX_ENV }}" > .env
          
          echo "âœ… .env file created (checking POSTGRES_URL is set)..."
          if grep -q "POSTGRES_URL" .env; then
            echo "âœ… POSTGRES_URL found in .env"
            # Show which port is being used (masked)
            POSTGRES_URL_LINE=$(grep "^POSTGRES_URL=" .env | head -1)
            if echo "$POSTGRES_URL_LINE" | grep -q ":6543"; then
              echo "   Using connection pooler (port 6543)"
            elif echo "$POSTGRES_URL_LINE" | grep -q ":5432"; then
              echo "   Using direct connection (port 5432) - ensure IP is allowlisted in Supabase"
            else
              PORT=$(echo "$POSTGRES_URL_LINE" | sed 's/.*:\([0-9]*\).*/\1/' || echo "unknown")
              echo "   Using port: $PORT"
            fi
            # Check if database name is included (should be removed for Convex)
            if echo "$POSTGRES_URL_LINE" | grep -q "/postgres"; then
              echo "   âš ï¸  WARNING: Connection string contains '/postgres' - removing it (Convex creates its own database)"
              # Remove /postgres and any trailing path from the connection string
              FIXED_URL=$(echo "$POSTGRES_URL_LINE" | sed 's|/postgres.*||' | sed 's|/$||')
              sed -i "s|^POSTGRES_URL=.*|${FIXED_URL}|" .env
              echo "   âœ… Removed '/postgres' from POSTGRES_URL"
            fi
          else
            echo "âš ï¸  WARNING: POSTGRES_URL not found in .env (will use SQLite if not set)"
          fi
          
          # Configure IPv4 preference to avoid IPv6 connection issues
          # This ensures DNS resolution prefers IPv4 addresses
          echo "ðŸ”§ Configuring IPv4 preference for DNS resolution..."
          if [ -f /etc/gai.conf ]; then
            if ! grep -q "^precedence ::ffff:0:0/96  100" /etc/gai.conf; then
              echo "   Adding IPv4 preference to /etc/gai.conf..."
              sudo sh -c 'echo "precedence ::ffff:0:0/96  100" >> /etc/gai.conf' 2>&1 || echo "   âš ï¸  Could not modify /etc/gai.conf (may need sudo, continuing anyway)"
            else
              echo "   âœ… IPv4 preference already configured in /etc/gai.conf"
            fi
          else
            echo "   Creating /etc/gai.conf to prefer IPv4..."
            sudo sh -c 'echo "precedence ::ffff:0:0/96  100" > /etc/gai.conf' 2>&1 || echo "   âš ï¸  Could not create /etc/gai.conf (may need sudo, continuing anyway)"
          fi
          
          # Workaround: If POSTGRES_URL contains a hostname, try to resolve to IPv4 and use it
          # This helps when DNS returns IPv6 but EC2 doesn't have IPv6 connectivity
          if grep -q "POSTGRES_URL" .env; then
            POSTGRES_URL=$(grep "^POSTGRES_URL=" .env | cut -d'=' -f2-)
            if echo "$POSTGRES_URL" | grep -q "@.*:"; then
              HOSTNAME=$(echo "$POSTGRES_URL" | sed 's/.*@\([^:]*\):.*/\1/')
              PORT=$(echo "$POSTGRES_URL" | sed 's/.*:\([0-9]*\).*/\1/')
              echo "   Resolving $HOSTNAME to IPv4 address..."
              
              # Try multiple methods to get IPv4 address
              IPV4_ADDR=""
              
              # Method 1: dig with external DNS resolver (Google DNS) - forces IPv4
              if command -v dig &> /dev/null; then
                echo "   Trying dig with Google DNS (8.8.8.8)..."
                IPV4_ADDR=$(dig @8.8.8.8 +short A "$HOSTNAME" 2>/dev/null | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$' | head -1)
              fi
              
              # Method 2: dig with Cloudflare DNS
              if [ -z "$IPV4_ADDR" ] && command -v dig &> /dev/null; then
                echo "   Trying dig with Cloudflare DNS (1.1.1.1)..."
                IPV4_ADDR=$(dig @1.1.1.1 +short A "$HOSTNAME" 2>/dev/null | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$' | head -1)
              fi
              
              # Method 3: dig with default resolver
              if [ -z "$IPV4_ADDR" ] && command -v dig &> /dev/null; then
                echo "   Trying dig with default resolver..."
                IPV4_ADDR=$(dig +short A "$HOSTNAME" 2>/dev/null | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$' | head -1)
              fi
              
              # Method 4: host command with external DNS
              if [ -z "$IPV4_ADDR" ] && command -v host &> /dev/null; then
                echo "   Trying host with Google DNS..."
                IPV4_ADDR=$(host -t A "$HOSTNAME" 8.8.8.8 2>/dev/null | grep "has address" | awk '{print $4}' | head -1)
              fi
              
              # Method 5: getent (fallback)
              if [ -z "$IPV4_ADDR" ]; then
                echo "   Trying getent..."
                IPV4_ADDR=$(getent ahostsv4 "$HOSTNAME" 2>/dev/null | grep "STREAM" | awk '{print $1}' | head -1)
              fi
              
              # Method 6: nslookup with external DNS
              if [ -z "$IPV4_ADDR" ]; then
                echo "   Trying nslookup with Google DNS..."
                IPV4_ADDR=$(nslookup "$HOSTNAME" 8.8.8.8 2>/dev/null | grep -A 1 "Name:" | grep "Address:" | awk '{print $2}' | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$' | head -1)
              fi
              
              # Method 7: curl to resolve (last resort)
              if [ -z "$IPV4_ADDR" ] && command -v curl &> /dev/null; then
                echo "   Trying curl to resolve..."
                # Use a simple HTTP request to resolve DNS
                IPV4_ADDR=$(curl -s "https://dns.google/resolve?name=$HOSTNAME&type=A" 2>/dev/null | grep -oE '"data":"[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+"' | head -1 | cut -d'"' -f4)
              fi
              
              if [ -n "$IPV4_ADDR" ] && [[ "$IPV4_ADDR" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                echo "   âœ… Found IPv4: $IPV4_ADDR"
                echo "   Updating POSTGRES_URL to use IPv4 address (port $PORT)..."
                NEW_POSTGRES_URL=$(echo "$POSTGRES_URL" | sed "s/@${HOSTNAME}:/@${IPV4_ADDR}:/")
                sed -i "s|^POSTGRES_URL=.*|POSTGRES_URL=${NEW_POSTGRES_URL}|" .env
                echo "   âœ… Updated POSTGRES_URL to use IPv4: ${NEW_POSTGRES_URL//:[^:]*@/:***@}"
              else
                echo "   âŒ Could not resolve $HOSTNAME to IPv4 address using any method"
                echo ""
                echo "   ðŸ”§ MANUAL FIX REQUIRED:"
                echo "   1. Get IPv4 address manually (run from your local machine):"
                echo "      dig +short A $HOSTNAME"
                echo "      OR"
                echo "      nslookup $HOSTNAME 8.8.8.8"
                echo ""
                echo "   2. Update your GitHub secret CONVEX_ENV with POSTGRES_URL using the IPv4 address:"
                echo "      POSTGRES_URL=postgresql://postgres:[PASSWORD]@[IPv4_ADDRESS]:$PORT"
                echo ""
                echo "   3. Alternative: Switch to direct connection (port 5432) and allowlist EC2 IP in Supabase"
                echo "      - Supabase Dashboard â†’ Settings â†’ Database â†’ Add your EC2 IP"
                echo "      - Update POSTGRES_URL to use port 5432"
                echo ""
                echo "   âš ï¸  Continuing with hostname (will likely fail due to IPv6 issue)..."
              fi
            fi
          fi
          
          # Ensure Docker is running
          sudo systemctl start docker || true
          sudo chmod 666 /var/run/docker.sock || true
          
          # Detect docker-compose command
          echo "ðŸ” Detecting Docker Compose command..."
          DOCKER_COMPOSE_CMD=""
          if command -v docker-compose &> /dev/null; then
            DOCKER_COMPOSE_CMD="docker-compose"
            echo "âœ… Using docker-compose (standalone)"
          elif docker compose version &> /dev/null; then
            DOCKER_COMPOSE_CMD="docker compose"
            echo "âœ… Using docker compose (plugin)"
          else
            echo "âŒ Docker Compose not found. Installing..."
            sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
            DOCKER_COMPOSE_CMD="docker-compose"
            echo "âœ… Installed docker-compose"
          fi
          
          echo "ðŸ“¥ Pulling latest Docker images..."
          $DOCKER_COMPOSE_CMD -f docker-compose.prod.yml pull
          
          echo "ðŸ”„ Stopping existing services..."
          $DOCKER_COMPOSE_CMD -f docker-compose.prod.yml down || true
          
          echo "âœ… Starting services with latest images..."
          $DOCKER_COMPOSE_CMD -f docker-compose.prod.yml up -d || true
          
          echo "â³ Waiting a moment for containers to start..."
          sleep 3
          
          echo "ðŸ“‹ Checking container status..."
          docker ps -a --filter "name=convex" || true
          
          echo "ðŸ“ Backend logs (last 100 lines):"
          $DOCKER_COMPOSE_CMD -f docker-compose.prod.yml logs backend --tail 100 2>&1 || docker logs convex-backend-backend-1 --tail 100 2>&1 || echo "Could not retrieve logs"
          
          echo "ðŸ“ Checking if backend container exists and its exit code:"
          docker inspect convex-backend-backend-1 --format '{{.State.Status}} - Exit Code: {{.State.ExitCode}}' 2>&1 || echo "Container not found"
          
          echo "ðŸ“ Checking .env file (first few lines, masked):"
          head -5 .env | sed 's/=.*/=***/' || true
          
          echo "ðŸŒ Testing network connectivity to Supabase..."
          POSTGRES_URL_LINE=$(grep "^POSTGRES_URL=" .env | head -1 || echo "")
          if [ -n "$POSTGRES_URL_LINE" ]; then
            POSTGRES_HOST=$(echo "$POSTGRES_URL_LINE" | sed 's/.*@\([^:]*\):.*/\1/')
            POSTGRES_PORT=$(echo "$POSTGRES_URL_LINE" | sed 's/.*:\([0-9]*\).*/\1/')
            echo "Testing connection to: $POSTGRES_HOST:$POSTGRES_PORT"
            
            # Check if it's an IP address or hostname
            if [[ "$POSTGRES_HOST" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "   Using IP address directly: $POSTGRES_HOST"
              echo "   Testing IPv4 connection:"
              timeout 5 nc -4 -zv $POSTGRES_HOST $POSTGRES_PORT 2>&1 && echo "   âœ… Port $POSTGRES_PORT is reachable" || echo "   âŒ Port $POSTGRES_PORT NOT reachable"
            else
              echo "   Resolving hostname to IPv4..."
              IPV4_ADDR=""
              # Try external DNS resolvers first (more reliable for IPv4)
              if command -v dig &> /dev/null; then
                IPV4_ADDR=$(dig @8.8.8.8 +short A "$POSTGRES_HOST" 2>/dev/null | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$' | head -1)
              fi
              if [ -z "$IPV4_ADDR" ] && command -v dig &> /dev/null; then
                IPV4_ADDR=$(dig @1.1.1.1 +short A "$POSTGRES_HOST" 2>/dev/null | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$' | head -1)
              fi
              if [ -z "$IPV4_ADDR" ] && command -v dig &> /dev/null; then
                IPV4_ADDR=$(dig +short A "$POSTGRES_HOST" 2>/dev/null | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$' | head -1)
              fi
              if [ -z "$IPV4_ADDR" ] && command -v host &> /dev/null; then
                IPV4_ADDR=$(host -t A "$POSTGRES_HOST" 8.8.8.8 2>/dev/null | grep "has address" | awk '{print $4}' | head -1)
              fi
              
              if [ -n "$IPV4_ADDR" ]; then
                echo "   âœ… Resolved to IPv4: $IPV4_ADDR"
                echo "   Testing connection to $IPV4_ADDR:$POSTGRES_PORT:"
                timeout 5 nc -4 -zv $IPV4_ADDR $POSTGRES_PORT 2>&1 && echo "   âœ… Port $POSTGRES_PORT is reachable" || echo "   âŒ Port $POSTGRES_PORT NOT reachable"
              else
                echo "   âš ï¸  Could not resolve to IPv4, testing hostname directly:"
                timeout 5 nc -4 -zv $POSTGRES_HOST $POSTGRES_PORT 2>&1 && echo "   âœ… Port $POSTGRES_PORT is reachable" || echo "   âŒ Port $POSTGRES_PORT NOT reachable"
                echo "   Testing IPv6 (may fail if EC2 doesn't have IPv6):"
                timeout 5 nc -6 -zv $POSTGRES_HOST $POSTGRES_PORT 2>&1 && echo "   âœ… IPv6 port $POSTGRES_PORT is reachable" || echo "   âŒ IPv6 port $POSTGRES_PORT NOT reachable"
              fi
            fi
            
            # Also test the alternative port (5432 vs 6543)
            if [ "$POSTGRES_PORT" = "6543" ]; then
              echo "   ðŸ’¡ Tip: If port 6543 fails, try direct connection on port 5432 (requires IP allowlisting in Supabase)"
            elif [ "$POSTGRES_PORT" = "5432" ]; then
              echo "   ðŸ’¡ Tip: If port 5432 fails, ensure your EC2 IP is allowlisted in Supabase Dashboard â†’ Settings â†’ Database"
            fi
          fi
          
          echo "â³ Waiting for backend to be healthy..."
          sleep 10
          
          echo "ðŸ¥ Checking backend health..."
          if curl -f http://localhost:3210/version > /dev/null 2>&1; then
            echo "âœ… Backend is healthy!"
          else
            echo "âš ï¸  Backend health check failed!"
            echo "ðŸ“ Full backend logs:"
            $DOCKER_COMPOSE_CMD -f docker-compose.prod.yml logs backend 2>&1 || docker logs convex-backend-backend-1 2>&1 || true
            echo "ðŸ“ Checking POSTGRES_URL:"
            grep "POSTGRES_URL" .env | head -1 | sed 's/=.*/=***/' || echo "POSTGRES_URL not found in .env"
            echo "ðŸŒ Network diagnostics:"
            echo "Testing internet connectivity:"
            curl -s --max-time 5 https://www.google.com > /dev/null && echo "âœ… Internet connection works" || echo "âŒ No internet connection"
            echo "Testing DNS resolution:"
            POSTGRES_HOST=$(grep POSTGRES_URL .env | sed 's/.*@\([^:]*\):.*/\1/' || echo "")
            if [ -n "$POSTGRES_HOST" ]; then
              nslookup $POSTGRES_HOST 2>&1 | head -5 || echo "DNS lookup failed"
            fi
            exit 1
          fi
          
          echo "ðŸ“Š Service Status:"
          docker ps --filter "name=convex" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          
          echo ""
          echo "ðŸ“‹ Docker Compose Version:"
          $DOCKER_COMPOSE_CMD --version || $DOCKER_COMPOSE_CMD version
          
          echo ""
          echo "âœ… Deployment complete!"
